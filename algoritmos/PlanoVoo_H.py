# -*- coding: utf-8 -*-

"""
/***************************************************************************
 PlanoVoo
                                 A QGIS plugin
 PlanoVoo
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-05
        copyright            : (C) 2024 by Prof Cazaroli e Leandro França
        email                : contato@geoone.com.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Prof Cazaroli e Leandro França'
__date__ = '2024-11-05'
__copyright__ = '(C) 2024 by Prof Cazaroli e Leandro França'
__revision__ = '$Format:%H$'

from qgis.core import QgsProcessing, QgsProject, QgsProcessingAlgorithm
from qgis.core import QgsProcessingParameterVectorLayer, QgsProcessingParameterNumber
from qgis.core import QgsTextFormat, QgsTextBufferSettings, QgsProcessingParameterFileDestination
from qgis.core import QgsPalLayerSettings, QgsVectorLayerSimpleLabeling
from qgis.core import QgsVectorLayer, QgsPoint, QgsPointXY, QgsField, QgsFields, QgsFeature, QgsGeometry
from qgis.core import QgsMarkerSymbol, QgsSingleSymbolRenderer, QgsSimpleLineSymbolLayer, QgsLineSymbol
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QColor, QFont, QIcon
from PyQt5.QtCore import QVariant
import processing
import os
import math

# pontos_provider Air 2S (5472 × 3648)

class PlanoVoo_H(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterVectorLayer('terreno', 'Terreno do Voo', types=[QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterNumber('h','Altura de Voo',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=50,defaultValue=100))
        self.addParameter(QgsProcessingParameterNumber('dc','Tamanho do Sensor Horizontal (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=13.2e-3)) # igual p/o Phantom 4 Pro (5472 × 3648)
        self.addParameter(QgsProcessingParameterNumber('dl','Tamanho do Sensor Vertical (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=8.8e-3)) # igual p/o Phantom 4 Pro
        self.addParameter(QgsProcessingParameterNumber('f','Distância Focal (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=8.38e-3)) # Phantom 4 Pro é f = 9e-3
        self.addParameter(QgsProcessingParameterNumber('percL','Percentual de sobreposição Lateral (75% = 0.75)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0.60,defaultValue=0.75))
        self.addParameter(QgsProcessingParameterNumber('percF','Percentual de sobreposição Frontal (85% = 0.85)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0.60,defaultValue=0.85))
        self.addParameter(QgsProcessingParameterFileDestination('saida_csv', 'Arquivo de Saída CSV para o Litchi',
                                                               fileFilter='CSV files (*.csv)'))
        self.addParameter(QgsProcessingParameterFileDestination('saida_kml', 'Arquivo de Saída KML para o Google Earth',
                                                               fileFilter='KML files (*.kml)'))
        
    def processAlgorithm(self, parameters, context, feedback):
        # =====Parâmetros de entrada para variáveis========================
        camada = self.parameterAsVectorLayer(parameters, 'terreno', context)
        crs = camada.crs()

        H = parameters['h']
        dc = parameters['dc']
        dl = parameters['dl']
        f = parameters['f']
        percL = parameters['percL'] # Lateral
        percF = parameters['percF'] # Frontal
        caminho_csv = parameters['saida_csv']
        caminho_kml = parameters, ['saida_kml']
        
        # =====Cálculo das Sobreposições====================================
        # Distância das linhas de voo paralelas - Espaçamento Lateral
        tg_alfa_2 = dc / (2 * f)
        D_lat = dc * H / f
        SD_lat = percL * D_lat
        h1 = SD_lat / (2 * tg_alfa_2)
        deltaLat = SD_lat * (H / h1 - 1)

        # Espaçamento Frontal entre as fotografias- Espaçamento Frontal
        tg_alfa_2 = dl / (2 * f)
        D_front = dl * H / f
        SD_front = percF * D_front
        h1 = SD_front / (2 * tg_alfa_2)
        deltaFront = SD_front * (H / h1 - 1)
        
        feedback.pushInfo(f"Delta Lateral: {deltaLat}, Delta Frontal: {deltaFront}")
        
        # =====================================================================
        # ===== Determinação das Linhas de Voo ================================
        f = next(camada.getFeatures())
        geom = f.geometry()
        
        vertices = list(geom.vertices())
        
        # maior distância entre vértices -> maior_distancia
        maior_distancia = 0

        for i in range(len(vertices)):
            for j in range(i + 1, len(vertices)):
                ponto_a = vertices[i]
                ponto_b = vertices[j]
                
                # Calcular a distância entre os dois vértices
                dist = ponto_a.distance(ponto_b)
                
                # Verificar se essa distância é a maior encontrada até agora
                if dist > maior_distancia:
                    maior_distancia = dist
        
        # maior lado do polígono -> maior_lado (distância), p1 e p2 (geom Pontos) e lado_mais_longo (geom Linha)
        p1 = p2 = None
        maior_lado = 0

        for i in range(len(vertices) - 1):
            ponto_a = vertices[i]
            ponto_b = vertices[i + 1]
            
            # Calcular a distância entre os dois pontos
            dist = ponto_a.distance(ponto_b)
            
            # Verificar se essa distância é a maior
            if dist > maior_lado:
                maior_lado = dist
                p1 = ponto_a
                p2 = ponto_b

        lado_mais_longo = QgsGeometry.fromPolylineXY([QgsPointXY(p1), QgsPointXY(p2)])
        
        # Criar a linha estendida e depois realizar a interseção
        dx = p2.x() - p1.x()
        dy = p2.y() - p1.y()
        angulo = math.atan2(dy, dx)
        
        extensao_x = maior_distancia * math.cos(angulo)
        extensao_y = maior_distancia * math.sin(angulo)
        
        p1_estendido = QgsPointXY(p1.x() - extensao_x ,p1.y() - extensao_y)
        p2_estendido = QgsPointXY(p2.x() + extensao_x ,p2.y() + extensao_y)
        lado_estendido = QgsGeometry.fromPolylineXY([QgsPointXY(p1_estendido), QgsPointXY(p2_estendido)])
        
        # Agora, encontrar o vértice mais oposto -> dist_P (distância) e ponto_oposto (geom Ponto)
        ponto_oposto = None
        dist_P = 0 

        for i in range(len(vertices)):
            ponto_atual = vertices[i]
            
            # Calcular a distância entre o ponto atual e o maior lado do polígono
            dist = lado_mais_longo.distance(QgsGeometry.fromPointXY(QgsPointXY(ponto_atual)))
             
            # Verificar se é a maior distância
            if dist > dist_P:
                dist_P = dist
                ponto_oposto = ponto_atual
        
        # Criar a linha temporária sobre o lado mais longo do Polígono = Primeira Linha  
        # lado_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Lado Mais Longo', 'memory')
        # lado_provider = lado_layer.dataProvider()
        # lado_provider.addAttributes([QgsField('id', QVariant.Int)])
        # lado_layer.updateFields()

        # lado_feature = QgsFeature()
        # lado_feature.setGeometry(lado_mais_longo)
        # lado_feature.setAttributes([1]) 
        # lado_provider.addFeature(lado_feature)
        
        # QgsProject.instance().addMapLayer(lado_layer)

        # Criar camada temporária para o ponto oposto
        # ponto_layer = QgsVectorLayer('Point?crs=' + crs.authid(), 'Ponto Oposto', 'memory')
        # ponto_provider = ponto_layer.dataProvider()
        # ponto_provider.addAttributes([QgsField('id', QVariant.Int)])
        # ponto_layer.updateFields()

        # ponto_feature = QgsFeature()
        # ponto_feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(ponto_oposto)))
        # ponto_feature.setAttributes([1])  # Atribuindo um valor qualquer, pode ser ajustado
        # ponto_provider.addFeature(ponto_feature)

        # QgsProject.instance().addMapLayer(ponto_layer)
  
        # Criar as Paralelas
        paralelas_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linhas Paralelas', 'memory')
        paralelas_provider = paralelas_layer.dataProvider()
        paralelas_provider.addAttributes([QgsField('id', QVariant.Int)])
        paralelas_layer.updateFields()
        
        # Incluir o lado mais longo como a primeira linha paralela
        linha_id = 1
        paralela_feature = QgsFeature()
        paralela_feature.setGeometry(lado_estendido)
        paralela_feature.setAttributes([linha_id])
        paralelas_provider.addFeature(paralela_feature)
        
        # Calcular o produto vetorial para determinar a direção das linhas paralelas
        vetor_linha = QgsPointXY(p2.x() - p1.x(), p2.y() - p1.y())  # Vetor da linha
        vetor_ponto = QgsPointXY(ponto_oposto.x() - p1.x(), ponto_oposto.y() - p1.y())
        direcao = vetor_linha.x() * vetor_ponto.y() - vetor_linha.y() * vetor_ponto.x()
        if direcao > 0:
            sentido = 1  # Ponto está à direita
        else:
            sentido = -1 # Ponto está à esquerda
            
        deslocamento = 0
        linha_base = paralelas_layer
        
        #feedback.pushInfo(f"Sentido: {sentido}, Dist_P: {dist_P}")
        
        while abs(deslocamento) < dist_P: # Linhas paralelas a partir da Linha criada
            linha_id += 1
            
            parameters = {
                'INPUT': linha_base,
                'DISTANCE': deltaLat * sentido,
                'OUTPUT': 'memory:'
            }
        
            result = processing.run("native:offsetline", parameters)
            linha_paralela_layer = result['OUTPUT']
            
            feature = next(linha_paralela_layer.getFeatures(), None)
            linha_geom = feature.geometry()
            intersecao_geom = linha_geom.intersection(geom)
            
            paralela_feature = QgsFeature()
            paralela_feature.setGeometry(intersecao_geom)
            paralela_feature.setAttributes([linha_id])
            paralelas_layer.dataProvider().addFeature(paralela_feature)
            paralelas_layer.updateExtents()
            
            linha_base = linha_paralela_layer
           
            deslocamento += deltaLat * sentido

        # Interseção da linha base (lado estendido) com o polígono
        primeira_linha = next(paralelas_layer.getFeatures())
        primeira_linha.setGeometry(lado_mais_longo)
        paralelas_provider.changeGeometryValues({primeira_linha.id(): lado_mais_longo})
        paralelas_layer.updateExtents()

        # Verificar se a última linha paralela está fora do polígono
        linha_features = list(paralelas_layer.getFeatures())
        ultima_linha = linha_features[-1]
        ultima_geom = ultima_linha.geometry()
        intersecao_geom = ultima_geom.intersection(geom)

        # Se a interseção estiver vazia, remover a última linha
        if intersecao_geom.isEmpty():
            paralelas_provider.deleteFeatures([ultima_linha.id()])
            paralelas_layer.updateExtents()
        
        # =====================================================================
        # Unir todas as linhas paralelas
        linha_features = list(paralelas_layer.getFeatures())
        geometrias = [feature.geometry() for feature in linha_features]

        # Criar uma camada de pontos temporária
        crs = paralelas_layer.crs()
        pontos_layer = QgsVectorLayer(f"Point?crs={crs.authid()}", "Pontos", "memory")
        pontos_provider = pontos_layer.dataProvider()

        # Adicionar campo para ID
        pontos_provider.addAttributes([QgsField("id", QVariant.Int)])
        pontos_layer.updateFields()

        # Listas para armazenar pontos pares e ímpares
        pontos_pares = []
        pontos_impares = []
        id_counter = 0

        for geom in geometrias:
            if geom.isMultipart():  # Se for uma geometria multipart
                partes = geom.asMultiPolyline()

                # Pegar o primeiro ponto do primeiro segmento e o último ponto do último segmento
                ponto_inicio = partes[0][0]  # Pega o primeiro ponto do primeiro segmento
                ponto_final = partes[-1][-1]  # Pega o último ponto do último segmento

                # Criar as geometrias dos pontos de início e final
                pontos = [ponto_inicio, ponto_final]

                for ponto in pontos:
                    ponto_geom = QgsGeometry.fromPointXY(QgsPointXY(ponto[0], ponto[1]))

                    ponto_feature = QgsFeature()
                    ponto_feature.setGeometry(ponto_geom)
                    ponto_feature.setAttributes([id_counter])

                    # Adicionar o ponto à camada
                    pontos_provider.addFeature(ponto_feature)

                    # Classificar em pares ou ímpares
                    if id_counter % 2 == 0:
                        pontos_pares.append(ponto_feature)
                    else:
                        pontos_impares.append(ponto_feature)
                    id_counter += 1

            else:  # Para geometrias de linha simples
                parte = geom.asPolyline()
                if len(parte) > 1:
                    # Incluir todos os pontos da linha simples
                    for ponto in parte:
                        ponto_geom = QgsGeometry.fromPointXY(QgsPointXY(ponto[0], ponto[1]))

                        ponto_feature = QgsFeature()
                        ponto_feature.setGeometry(ponto_geom)
                        ponto_feature.setAttributes([id_counter])

                        # Adicionar o ponto à camada
                        pontos_provider.addFeature(ponto_feature)

                        # Classificar em pares ou ímpares
                        if id_counter % 2 == 0:
                            pontos_pares.append(ponto_feature)
                        else:
                            pontos_impares.append(ponto_feature)
                        id_counter += 1

        # Atualizar a camada de pontos
        pontos_layer.updateExtents()
        
        # Adicionar a camada ao projeto
        #QgsProject.instance().addMapLayer(pontos_layer)

        # Criar segmentos diretamente na camada paralelas_layer
        paralelas_provider = paralelas_layer.dataProvider()

        # Criar segmentos conforme o padrão P2-P4, P6-P8, etc.
        novos_segmentos = []
        id_counter = len(paralelas_layer) + 1

        for i in range(1, len(pontos_pares), 2):
            try:
                p1 = pontos_pares[i].geometry().asPoint()
                p2 = pontos_pares[i + 1].geometry().asPoint()

                # Criar segmento entre os dois pontos
                segmento = QgsGeometry.fromPolylineXY([p1, p2])

                # Criar a feature do segmento
                segmento_feature = QgsFeature()
                segmento_feature.setGeometry(segmento)
                segmento_feature.setAttributes([id_counter])
                novos_segmentos.append(segmento_feature)

                id_counter += 1
            except:
                break

        # Criar segmentos conforme o padrão P1-P3, P5-P7, etc.
        for i in range(0, len(pontos_impares), 2):
            try:
                p1 = pontos_impares[i].geometry().asPoint()
                p2 = pontos_impares[i + 1].geometry().asPoint()

                # Criar segmento entre os dois pontos
                segmento = QgsGeometry.fromPolylineXY([p1, p2])

                # Criar a feature do segmento
                segmento_feature = QgsFeature()
                segmento_feature.setGeometry(segmento)
                segmento_feature.setAttributes([id_counter])
                novos_segmentos.append(segmento_feature)

                id_counter += 1
            except:
                break

        # Adicionar os novos segmentos à camada
        paralelas_provider.addFeatures(novos_segmentos)
        paralelas_layer.updateExtents()

        QgsProject.instance().addMapLayer(paralelas_layer)
        # =====================================================================
        # =====Criar a camada Pontos de Fotos==================================
        
        # Ordenar os segmentos de linha para garantir a sequência das Fotos
        linha_features = list(paralelas_layer.getFeatures())
        geometrias = []

        # Tratar separadamente MultiLineString e LineString
        for feature in linha_features:
            geom = feature.geometry()
            if geom.isMultipart():
                partes = geom.asMultiPolyline()
                for parte in partes:
                    geometrias.append(QgsGeometry.fromPolylineXY(parte))  # Adicionar cada parte como LineString
            else:
                geometrias.append(geom)  # Adicionar diretamente se for LineString

        # Criar uma nova camada para as linhas ordenadas
        crs = paralelas_layer.crs()
        nova_paralela_layer = QgsVectorLayer(f"LineString?crs={crs.authid()}", "Linhas Ordenadas", "memory")
        nova_paralela_provider = nova_paralela_layer.dataProvider()

        # Adicionar campo para ID na nova camada
        nova_paralela_provider.addAttributes([QgsField("id", QVariant.Int)])
        nova_paralela_layer.updateFields()

        # Ordenar as linhas com base na continuidade dos pontos extremos
        linhas_ordenadas = [geometrias.pop(0)]  # Começar com a primeira linha
        while geometrias:
            linha_atual = linhas_ordenadas[-1]  # Última linha adicionada
            pontos_linha_atual = linha_atual.asPolyline()  # Obter pontos da linha atual
            ponto_final_atual = pontos_linha_atual[-1]  # Último ponto da linha atual

            proxima_linha = None
            for linha in geometrias:
                pontos_linha = linha.asPolyline()
                ponto_inicial = pontos_linha[0]  # Primeiro ponto da próxima linha
                ponto_final = pontos_linha[-1]  # Último ponto da próxima linha

                # Verificar continuidade
                if ponto_inicial == ponto_final_atual:
                    proxima_linha = linha
                    break
                elif ponto_final == ponto_final_atual:
                    # Inverter a linha para garantir a continuidade
                    nova_geom = QgsGeometry.fromPolylineXY(list(reversed(pontos_linha)))
                    geometrias[geometrias.index(linha)] = nova_geom
                    proxima_linha = nova_geom
                    break

            # Adicionar a linha contínua à lista ordenada
            if proxima_linha:
                linhas_ordenadas.append(proxima_linha)
                geometrias.remove(proxima_linha)
            else:
                break  # Finalizar se não houver continuidade

        # Criar novos segmentos na camada nova
        id_counter = 1
        for linha in linhas_ordenadas:
            nova_feature = QgsFeature()
            nova_feature.setGeometry(linha)
            nova_feature.setAttributes([id_counter])
            nova_paralela_provider.addFeature(nova_feature)
            id_counter += 1

        # Atualizar a nova camada
        nova_paralela_layer.updateExtents()

        # Adicionar a camada ordenada ao projeto
        QgsProject.instance().addMapLayer(nova_paralela_layer)
       




        
        # Criar uma camada Ponto com os deltaFront sobre a linha
        pontos_fotos = QgsVectorLayer(f"Point?crs={crs}", "PontosFotos", "memory")
        pontos_provider = pontos_fotos.dataProvider()

        # Definir campos
        campos = QgsFields()
        campos.append(QgsField("id", QVariant.Int))
        campos.append(QgsField("latitude", QVariant.Double))
        campos.append(QgsField("longitude", QVariant.Double))
        pontos_provider.addAttributes(campos)
        pontos_fotos.updateFields()

        # Iterar sobre as linhas e criar pontos espaçados
        features = nova_paralela_layer.getFeatures()
        pontoID = 0

        for f in features:
            geom = f.geometry()
            distVoo = geom.length()
            
            x = 0
            while x < distVoo:
                ponto = geom.interpolate(x).asPoint()
                
                nova_feature = QgsFeature()
                nova_feature.setFields(campos)
                nova_feature.setAttribute("id", pontoID)
                nova_feature.setAttribute("latitude", ponto.y())
                nova_feature.setAttribute("longitude", ponto.x())
                
                nova_feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(ponto)))
                
                pontos_provider.addFeature(nova_feature)
                
                pontoID += 1
                x += deltaFront

        # Adicionar camada de pontos ao projeto
        QgsProject.instance().addMapLayer(pontos_fotos)

        # Simbologia e Rótulo
        simbolo = QgsMarkerSymbol.createSimple({'color': 'blue', 'size': '3'})
        renderer = QgsSingleSymbolRenderer(simbolo)
        pontos_fotos.setRenderer(renderer)

        settings = QgsPalLayerSettings()
        settings.fieldName = "id"
        settings.isExpression = True
        settings.enabled = True

        textoF = QgsTextFormat()
        textoF.setFont(QFont("Arial", 10, QFont.Bold))
        textoF.setSize(10)

        bufferS = QgsTextBufferSettings()
        bufferS.setEnabled(True)
        bufferS.setSize(1)  # Tamanho do buffer em milímetros
        bufferS.setColor(QColor("white"))  # Cor do buffer

        textoF.setBuffer(bufferS)
        settings.setFormat(textoF)

        pontos_fotos.setLabelsEnabled(True)
        pontos_fotos.setLabeling(QgsVectorLayerSimpleLabeling(settings))

        pontos_fotos.triggerRepaint()
        QgsProject.instance().addMapLayer(pontos_fotos)
        
        return {}
        
    def name(self):
        return 'PlanoVooH'.lower()

    def displayName(self):
        return self.tr('Pontos Fotos - Voo Horizontal')

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''
        
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PlanoVoo_H()
    
    def icon(self):
        return QIcon(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'images/PlanoVoo.png'))
    
    texto = "Este algoritmo calcula a sobreposição lateral e frontal de Voo de Drone, \
            fornecendo uma camada da 'Linha do Voo' e uma camada dos 'Pontos' para Fotos. \
            Gera ainda: a planilha CSV para importar no Litchi e o arquivo KML para Google Earth. \
            Se você usa um aplicativo para Voo que não seja o Litchi, pode usar os pontos gerados no QGIS."
    figura = 'images/PlanoVoo1.jpg'

    def shortHelpString(self):
        corpo = '''<div align="center">
                      <img src="'''+ os.path.join(os.path.dirname(os.path.dirname(__file__)), self.figura) +'''">
                      </div>
                      <div align="right">
                      <p align="right">
                      <b>'Autor: Prof Cazaroli     -     Leandro França'</b>
                      </p>'Geoone'</div>
                    </div>'''
        return self.tr(self.texto) + corpo

# -*- coding: utf-8 -*-

"""
/***************************************************************************
 PlanoVoo
                                 A QGIS plugin
 PlanoVoo
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-05
        copyright            : (C) 2024 by Prof Cazaroli e Leandro França
        email                : contato@geoone.com.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Prof Cazaroli e Leandro França'
__date__ = '2024-11-05'
__copyright__ = '(C) 2024 by Prof Cazaroli e Leandro França'
__revision__ = '$Format:%H$'

from qgis.core import QgsProcessing, QgsProject, QgsProcessingAlgorithm, QgsWkbTypes
from qgis.core import QgsProcessingParameterVectorLayer, QgsProcessingParameterNumber
from qgis.core import QgsTextFormat, QgsTextBufferSettings, QgsProcessingParameterFileDestination
from qgis.core import QgsPalLayerSettings, QgsVectorLayerSimpleLabeling, QgsProcessingParameterBoolean
from qgis.core import QgsVectorLayer, QgsPoint, QgsPointXY, QgsField, QgsFields, QgsFeature, QgsGeometry
from qgis.core import QgsMarkerSymbol, QgsSingleSymbolRenderer, QgsSimpleLineSymbolLayer, QgsLineSymbol
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QColor, QFont, QIcon
from PyQt5.QtCore import QVariant
import processing
import os
import math

# pontos_provider Air 2S (5472 × 3648)

class PlanoVoo_H(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterVectorLayer('terreno', 'Terreno do Voo', types=[QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterVectorLayer('primeira_linha','Primeira Linha de Voo', types=[QgsProcessing.TypeVectorLine]))
        self.addParameter(QgsProcessingParameterNumber('h','Altura de Voo',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=50,defaultValue=100))
        self.addParameter(QgsProcessingParameterNumber('dc','Tamanho do Sensor Horizontal (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=13.2e-3)) # igual p/o Phantom 4 Pro (5472 × 3648)
        self.addParameter(QgsProcessingParameterNumber('dl','Tamanho do Sensor Vertical (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=8.8e-3)) # igual p/o Phantom 4 Pro
        self.addParameter(QgsProcessingParameterNumber('f','Distância Focal (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=8.38e-3)) # Phantom 4 Pro é f = 9e-3
        self.addParameter(QgsProcessingParameterNumber('percL','Percentual de sobreposição Lateral (75% = 0.75)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0.60,defaultValue=0.75))
        self.addParameter(QgsProcessingParameterNumber('percF','Percentual de sobreposição Frontal (85% = 0.85)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0.60,defaultValue=0.85))
        self.addParameter(QgsProcessingParameterFileDestination('saida_csv', 'Arquivo de Saída CSV para o Litchi',
                                                               fileFilter='CSV files (*.csv)'))
        self.addParameter(QgsProcessingParameterFileDestination('saida_kml', 'Arquivo de Saída KML para o Google Earth',
                                                               fileFilter='KML files (*.kml)'))
        
    def processAlgorithm(self, parameters, context, feedback):
        # =====Parâmetros de entrada para variáveis========================
        camada = self.parameterAsVectorLayer(parameters, 'terreno', context)
        crs = camada.crs()
        
        primeira_linha  = self.parameterAsVectorLayer(parameters, 'primeira_linha', context)

        H = parameters['h']
        dc = parameters['dc']
        dl = parameters['dl']
        f = parameters['f']
        percL = parameters['percL'] # Lateral
        percF = parameters['percF'] # Frontal
        caminho_csv = parameters['saida_csv']
        caminho_kml = parameters, ['saida_kml']
        
        # =====Cálculo das Sobreposições====================================
        # Distância das linhas de voo paralelas - Espaçamento Lateral
        tg_alfa_2 = dc / (2 * f)
        D_lat = dc * H / f
        SD_lat = percL * D_lat
        h1 = SD_lat / (2 * tg_alfa_2)
        deltaLat = SD_lat * (H / h1 - 1)

        # Espaçamento Frontal entre as fotografias- Espaçamento Frontal
        tg_alfa_2 = dl / (2 * f)
        D_front = dl * H / f
        SD_front = percF * D_front
        h1 = SD_front / (2 * tg_alfa_2)
        deltaFront = SD_front * (H / h1 - 1)
        
        feedback.pushInfo(f"Delta Lateral: {deltaLat}, Delta Frontal: {deltaFront}")
        
        # =====================================================================
        # ===== Determinação das Linhas de Voo ================================
        
        # Verificar se o polígono e a primeira_linha contém exatamente uma feature
        poligono_features = list(camada.getFeatures()) # dados do Terreno
        if len(poligono_features) != 1:
            raise ValueError("A camada deve conter somente um polígono.")

        poligono = poligono_features[0].geometry()
        vertices = [QgsPointXY(v) for v in poligono.vertices()] # Extrair os vértices do polígono
        
        linha_features = list(primeira_linha.getFeatures())
        if len(linha_features) != 1:
            raise ValueError("A camada primeira_linha deve conter somente uma linha.")

        # Verifica a geometria da primeira linha
        linha_geom = linha_features[0].geometry() # Obter a geometria da linha
        
        if linha_geom.asMultiPolyline():
            linha_vertices = linha_geom.asMultiPolyline()[0]  # Se a linha for do tipo poly
        else:
            linha_vertices = linha_geom.asPolyline() 
        
        # Criar a geometria da linha basee
        linha_base = QgsGeometry.fromPolylineXY([QgsPointXY(p) for p in linha_vertices])  

        # Verificar se a linha base coincide com um lado do polígono (até a segunda casa decimal)
        flag = False
        for i in range(len(vertices) - 1):
            # Criar a geometria do lado do polígono (em ambas as orientações)
            lado = QgsGeometry.fromPolylineXY([QgsPointXY(vertices[i]), QgsPointXY(vertices[i + 1])])
            lado_invertido = QgsGeometry.fromPolylineXY([QgsPointXY(vertices[i + 1]), QgsPointXY(vertices[i])])

            # Comparar se a geometria da linha base é igual ao lado (considerando a inversão também)
            if lado.equals(linha_base) or lado_invertido.equals(linha_base):
                flag = True
                break
            
        #feedback.pushInfo(f"Lado {i} - Ponto 1: ({vertices[i].x()}, {vertices[i].y()}) | Ponto 2: ({vertices[i + 1].x()}, {vertices[i + 1].y()})")
        #feedback.pushInfo(f"Linha base - Ponto 1: ({linha_vertices[0].x()}, {linha_vertices[0].y()}) | Ponto 2: ({linha_vertices[1].x()}, {linha_vertices[1].y()})")

        if not flag:
            raise ValueError("A camada primeira_linha deve ser um dos lados do terreno.")
        
        # Encontrar os pontos extremos de cada lado da linha base (sempre terá 1 ou 2 pontos)
        ponto_extremo_dir = None
        ponto_extremo_esq = None
        dist_max_dir = float('-inf')
        dist_max_esq = float('-inf')

        # Iterar sobre os vértices do polígono
        ponto1 = QgsPointXY(linha_vertices[0])
        ponto2 = QgsPointXY(linha_vertices[1])

        for ponto_atual in vertices:
            # Calcular o produto vetorial (determinante) para determinar se o ponto está à direita ou à esquerda
            produto_vetorial = (ponto2.x() - ponto1.x()) * (ponto_atual.y() - ponto1.y()) - (ponto2.y() - ponto1.y()) * (ponto_atual.x() - ponto1.x())

            # Calcular a distância do ponto à linha
            dist = linha_base.distance(QgsGeometry.fromPointXY(ponto_atual))

            # Atualizar o ponto extremo à direita
            if produto_vetorial > 0 and dist > dist_max_dir:
                dist_max_dir = dist
                ponto_extremo_dir = ponto_atual

            # Atualizar o ponto extremo à esquerda
            elif produto_vetorial < 0 and dist > dist_max_esq:
                dist_max_esq = dist
                ponto_extremo_esq = ponto_atual

        # Adicionar os pontos extremos encontrados à lista
        pontos_extremos = []
        if ponto_extremo_dir:
            pontos_extremos.append(ponto_extremo_dir)
        if ponto_extremo_esq:
            pontos_extremos.append(ponto_extremo_esq)

        # Criar camada temporária para o(s) ponto(s) oposto(s); a maioria das vezes será um ponto só
        pontosExtremos_layer = QgsVectorLayer('Point?crs=' + crs.authid(), 'Pontos Extremos', 'memory')
        pontos_provider = pontosExtremos_layer.dataProvider()
        pontos_provider.addAttributes([QgsField('id', QVariant.Int)])
        pontosExtremos_layer.updateFields()

        # Adicionar os pontos extremos à camada temporária
        for feature_id, ponto in enumerate(pontos_extremos, start=1):
            if ponto:
                ponto_feature = QgsFeature()
                ponto_feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(ponto)))
                ponto_feature.setAttributes([feature_id])  # ID do ponto
                pontos_provider.addFeature(ponto_feature)

        #QgsProject.instance().addMapLayer(pontosExtremos_layer)
        
        # Criar uma linha estendida sobre a linha base
        
         # ponto inicial e final da linha base
        p1 = linha_vertices[0]
        p2 = linha_vertices[1]
        
        dx = p2.x() - p1.x()
        dy = p2.y() - p1.y()
        angulo = math.atan2(dy, dx)
        
        extensao_x = (dist_max_esq + dist_max_dir) * math.cos(angulo)
        extensao_y = (dist_max_esq + dist_max_dir) * math.sin(angulo)
        
        p1_estendido = QgsPointXY(p1.x() - extensao_x ,p1.y() - extensao_y)
        p2_estendido = QgsPointXY(p2.x() + extensao_x ,p2.y() + extensao_y)
        linha_estendida = QgsGeometry.fromPolylineXY([QgsPointXY(p1_estendido), QgsPointXY(p2_estendido)])

        # Criar camada temporária para a linha estendida
        linhaEstendida_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linha Estendida', 'memory')
        linha_provider = linhaEstendida_layer.dataProvider()
        linha_provider.addAttributes([QgsField('id', QVariant.Int)])
        linhaEstendida_layer.updateFields()

        # Adicionar a linha estendida à camada temporária
        linha_feature = QgsFeature()
        linha_feature.setGeometry(linha_estendida)
        linha_feature.setAttributes([1])  # ID da linha estendida
        linha_provider.addFeature(linha_feature)

        #QgsProject.instance().addMapLayer(linhaEstendida_layer)
        
        # Criar linhas Paralelas à linha base até o(s) ponto(s) extremo(s)
        paralelas_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linhas Paralelas', 'memory')
        paralelas_provider = paralelas_layer.dataProvider()
        paralelas_provider.addAttributes([QgsField('id', QVariant.Int)])
        paralelas_layer.updateFields()
        
        # Incluir a linha como a primeira linha paralela
        # Interseção da linha paralela com o polígono
        intersecao_geom = linha_estendida.intersection(poligono)
        
        linha_id = 1
        paralela_feature = QgsFeature()
        paralela_feature.setGeometry(intersecao_geom)
        paralela_feature.setAttributes([linha_id])
        paralelas_provider.addFeature(paralela_feature)

        pontos_extremos = []
        if ponto_extremo_dir:  # Se existe o ponto extremo à direita
            dist = linha_estendida.distance(QgsGeometry.fromPointXY(QgsPointXY(ponto_extremo_dir))) if ponto_extremo_dir else 0
            pontos_extremos.append((dist, 1))  # Distância e sentido para o ponto direito
            
        if ponto_extremo_esq:  # Se existe o ponto extremo à esquerda
            dist = linha_estendida.distance(QgsGeometry.fromPointXY(QgsPointXY(ponto_extremo_esq))) if ponto_extremo_esq else 0
            pontos_extremos.append((dist, -1))  # Distância e sentido para o ponto esquerdo

        # Criar as paralelas em um sentido de cada vez
        for dist, sentido in pontos_extremos:
            deslocamento = deltaLat * sentido  # Usando a direção positiva ou negativa
            
            while abs(deslocamento) <= dist:  # Criar linhas paralelas até o ponto extremo
                linha_id += 1

                # Deslocamento da linha base para criar a paralela
                parameters = {
                    'INPUT': linhaEstendida_layer,  # Linha base
                    'DISTANCE': deslocamento,
                    'OUTPUT': 'memory:'
                }

                result = processing.run("native:offsetline", parameters)
                linha_paralela_layer = result['OUTPUT']
                
                # Obter a geometria da linha paralela
                feature = next(linha_paralela_layer.getFeatures(), None)
                linha_geom = feature.geometry() if feature else None

                if linha_geom:
                    # Interseção da linha paralela com o polígono
                    intersecao_geom = linha_geom.intersection(poligono)

                    # Adicionar a paralela à camada
                    paralela_feature = QgsFeature()
                    paralela_feature.setGeometry(intersecao_geom)
                    paralela_feature.setAttributes([linha_id])
                    paralelas_provider.addFeature(paralela_feature)
                    paralelas_layer.updateExtents()

                    # Atualizar a linha base para a próxima paralela
                    linha_estendida = linha_paralela_layer

                    deslocamento += deltaLat * sentido  # Atualizar o deslocamento

        # # Verificar se há linhas fora do polígono
        # linha_features = list(paralelas_layer.getFeatures())
        
        # # Lista para armazenar os IDs das feições a serem deletadas
        # ids_para_remover = []
        
        # for linha in linha_features:
        #     geom_linha = linha.geometry()
            
        #     # Verificar se a geometria da linha está fora do polígono
        #     intersecao_geom = geom_linha.intersection(geom)
        #     if intersecao_geom.isEmpty():
        #         # Adicionar o ID da feição à lista para remoção se estiver fora
        #         ids_para_remover.append(linha.id())
                
        # # Remover as feições fora ou sobre o polígono
        # if ids_para_remover:
        #     paralelas_provider.deleteFeatures(ids_para_remover)
        #     paralelas_layer.updateExtents()
        
        # Adicionar a camada ao projeto       
        QgsProject.instance().addMapLayer(paralelas_layer)
        """
        
        
        # Geração das linhas de costura diretamente na camada Linha de Voo
        paralelas_features = list(paralelas_layer.getFeatures())

        # Criar a camada de linha de voo
        linha_voo_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linha de Voo', 'memory')
        linha_voo_provider = linha_voo_layer.dataProvider()
        linha_voo_provider.addAttributes([QgsField('id', QVariant.Int)])
        linha_voo_layer.updateFields()

        # Adicionar as feições ordenadas à camada de linha de voo
        linha_id = 1  # Iniciar a numeração das linhas de voo a partir de 1

        # A primeira linha é a linha inicial
        for feature in paralelas_features:
            feature.setAttributes([linha_id])  # Atribui o ID à linha
            linha_voo_provider.addFeature(feature)  # Adiciona a linha na camada
            linha_id += 1  # Incrementa a numeração

        # Iterar pelas linhas paralelas consecutivas para gerar conexões
        for i in range(len(paralelas_features) - 1):
            linha_atual = paralelas_features[i]
            linha_seguinte = paralelas_features[i + 1]

            geom_atual = linha_atual.geometry()
            geom_seguinte = linha_seguinte.geometry()

            # Obter os extremos das linhas (converter iteradores em listas)
            extremos_atual = list(geom_atual.vertices())
            extremos_seguinte = list(geom_seguinte.vertices())

            # Criar conexões alternadas pelas laterais do polígono
            if i % 2 == 0:  # Conecta lateral direita
                ponto_inicio = QgsPointXY(extremos_atual[-1])  # Extremo direito da linha atual
                ponto_fim = QgsPointXY(extremos_seguinte[-1])  # Extremo direito da próxima linha
            else:  # Conecta lateral esquerda
                ponto_inicio = QgsPointXY(extremos_atual[0])   # Extremo esquerdo da linha atual
                ponto_fim = QgsPointXY(extremos_seguinte[0])   # Extremo esquerdo da próxima linha

            # Criar a linha de conexão
            conexao_geom = QgsGeometry.fromPolylineXY([ponto_inicio, ponto_fim])
            conexao_feature = QgsFeature()
            conexao_feature.setGeometry(conexao_geom)
            conexao_feature.setAttributes([linha_id])  # ID para a linha de conexão
            linha_voo_provider.addFeature(conexao_feature)

            linha_id += 1  # Incrementa a numeração após cada conexão

        # Atualizar extensão da camada de resultado
        linha_voo_layer.updateExtents()

        # Adicionar a camada final ao projeto
        QgsProject.instance().addMapLayer(linha_voo_layer)
        """
        
        """
        # =====================================================================
        # =====Criar a camada Pontos de Fotos==================================
        
        # Criar uma camada Ponto com os deltaFront sobre a linha
        pontos_fotos = QgsVectorLayer(f"Point?crs={crs}", "PontosFotos", "memory")
        pontos_provider = pontos_fotos.dataProvider()

        # Definir campos
        campos = QgsFields()
        campos.append(QgsField("id", QVariant.Int))
        campos.append(QgsField("latitude", QVariant.Double))
        campos.append(QgsField("longitude", QVariant.Double))
        pontos_provider.addAttributes(campos)
        pontos_fotos.updateFields()

        # Iterar sobre as linhas e criar pontos espaçados
        features = linha_voo_layer.getFeatures()
        pontoID = 0

        for f in features:
            geom = f.geometry()
            distVoo = geom.length()
            
            x = 0
            while x < distVoo:
                ponto = geom.interpolate(x).asPoint()
                
                nova_feature = QgsFeature()
                nova_feature.setFields(campos)
                nova_feature.setAttribute("id", pontoID)
                nova_feature.setAttribute("latitude", ponto.y())
                nova_feature.setAttribute("longitude", ponto.x())
                
                nova_feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(ponto)))
                
                pontos_provider.addFeature(nova_feature)
                
                pontoID += 1
                x += deltaFront

        # Adicionar camada de pontos ao projeto
        QgsProject.instance().addMapLayer(pontos_fotos)

        # Simbologia e Rótulo
        simbolo = QgsMarkerSymbol.createSimple({'color': 'blue', 'size': '3'})
        renderer = QgsSingleSymbolRenderer(simbolo)
        pontos_fotos.setRenderer(renderer)

        settings = QgsPalLayerSettings()
        settings.fieldName = "id"
        settings.isExpression = True
        settings.enabled = True

        textoF = QgsTextFormat()
        textoF.setFont(QFont("Arial", 10, QFont.Bold))
        textoF.setSize(10)

        bufferS = QgsTextBufferSettings()
        bufferS.setEnabled(True)
        bufferS.setSize(1)  # Tamanho do buffer em milímetros
        bufferS.setColor(QColor("white"))  # Cor do buffer

        textoF.setBuffer(bufferS)
        settings.setFormat(textoF)

        pontos_fotos.setLabelsEnabled(True)
        pontos_fotos.setLabeling(QgsVectorLayerSimpleLabeling(settings))

        pontos_fotos.triggerRepaint()
        QgsProject.instance().addMapLayer(pontos_fotos)
        """
        return {}
        
    def name(self):
        return 'PlanoVooH'.lower()

    def displayName(self):
        return self.tr('Pontos Fotos - Voo Horizontal')

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''
        
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PlanoVoo_H()
    
    def icon(self):
        return QIcon(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'images/PlanoVoo.png'))
    
    texto = "Este algoritmo calcula a sobreposição lateral e frontal de Voo de Drone, \
            fornecendo uma camada da 'Linha do Voo' e uma camada dos 'Pontos' para Fotos. \
            Gera ainda: a planilha CSV para importar no Litchi e o arquivo KML para Google Earth. \
            Se você usa um aplicativo para Voo que não seja o Litchi, pode usar os pontos gerados no QGIS."
    figura = 'images/PlanoVoo1.jpg'

    def shortHelpString(self):
        corpo = '''<div align="center">
                      <img src="'''+ os.path.join(os.path.dirname(os.path.dirname(__file__)), self.figura) +'''">
                      </div>
                      <div align="right">
                      <p align="right">
                      <b>'Autor: Prof Cazaroli     -     Leandro França'</b>
                      </p>'Geoone'</div>
                    </div>'''
        return self.tr(self.texto) + corpo

# -*- coding: utf-8 -*-

"""
/***************************************************************************
 PlanoVoo
                                 A QGIS plugin
 PlanoVoo
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-05
        copyright            : (C) 2024 by Prof Cazaroli e Leandro França
        email                : contato@geoone.com.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Prof Cazaroli e Leandro França'
__date__ = '2024-11-05'
__copyright__ = '(C) 2024 by Prof Cazaroli e Leandro França'
__revision__ = '$Format:%H$'

from qgis.core import QgsProcessing, QgsProject, QgsProcessingAlgorithm
from qgis.core import QgsProcessingParameterVectorLayer, QgsProcessingParameterNumber
from qgis.core import QgsTextFormat, QgsTextBufferSettings, QgsProcessingParameterFileDestination
from qgis.core import QgsPalLayerSettings, QgsVectorLayerSimpleLabeling
from qgis.core import QgsVectorLayer, QgsPoint, QgsPointXY, QgsField, QgsFields, QgsFeature, QgsGeometry
from qgis.core import QgsMarkerSymbol, QgsSingleSymbolRenderer, QgsSimpleLineSymbolLayer, QgsLineSymbol
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QColor, QFont, QIcon
from PyQt5.QtCore import QVariant
import processing
import os
import math

# pontos_provider Air 2S (5472 × 3648)

class PlanoVoo_H(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterVectorLayer('terreno', 'Terreno do Voo', types=[QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterNumber('h','Altura de Voo',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=50,defaultValue=100))
        self.addParameter(QgsProcessingParameterNumber('dc','Tamanho do Sensor Horizontal (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=13.2e-3)) # igual p/o Phantom 4 Pro (5472 × 3648)
        self.addParameter(QgsProcessingParameterNumber('dl','Tamanho do Sensor Vertical (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=8.8e-3)) # igual p/o Phantom 4 Pro
        self.addParameter(QgsProcessingParameterNumber('f','Distância Focal (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=8.38e-3)) # Phantom 4 Pro é f = 9e-3
        self.addParameter(QgsProcessingParameterNumber('percL','Percentual de sobreposição Lateral (75% = 0.75)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0.60,defaultValue=0.75))
        self.addParameter(QgsProcessingParameterNumber('percF','Percentual de sobreposição Frontal (85% = 0.85)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0.60,defaultValue=0.85))
        self.addParameter(QgsProcessingParameterFileDestination('saida_csv', 'Arquivo de Saída CSV para o Litchi',
                                                               fileFilter='CSV files (*.csv)'))
        self.addParameter(QgsProcessingParameterFileDestination('saida_kml', 'Arquivo de Saída KML para o Google Earth',
                                                               fileFilter='KML files (*.kml)'))
        
    def processAlgorithm(self, parameters, context, feedback):
        # =====Parâmetros de entrada para variáveis========================
        camada = self.parameterAsVectorLayer(parameters, 'terreno', context)
        crs = camada.crs()

        H = parameters['h']
        dc = parameters['dc']
        dl = parameters['dl']
        f = parameters['f']
        percL = parameters['percL'] # Lateral
        percF = parameters['percF'] # Frontal
        caminho_csv = parameters['saida_csv']
        caminho_kml = parameters, ['saida_kml']
        
        # =====Cálculo das Sobreposições====================================
        # Distância das linhas de voo paralelas - Espaçamento Lateral
        tg_alfa_2 = dc / (2 * f)
        D_lat = dc * H / f
        SD_lat = percL * D_lat
        h1 = SD_lat / (2 * tg_alfa_2)
        deltaLat = SD_lat * (H / h1 - 1)

        # Espaçamento Frontal entre as fotografias- Espaçamento Frontal
        tg_alfa_2 = dl / (2 * f)
        D_front = dl * H / f
        SD_front = percF * D_front
        h1 = SD_front / (2 * tg_alfa_2)
        deltaFront = SD_front * (H / h1 - 1)
        
        feedback.pushInfo(f"Delta Lateral: {deltaLat}, Delta Frontal: {deltaFront}")
        
        # =====================================================================
        # ===== Determinação das Linhas de Voo ================================
        
        # maior lado do polígono
        f = next(camada.getFeatures())
        geom = f.geometry()
        
        vertices = list(geom.vertices())
        
        # maior distância entre vértices -> maior_distancia
        maior_distancia = 0

        for i in range(len(vertices)):
            for j in range(i + 1, len(vertices)):
                ponto_a = vertices[i]
                ponto_b = vertices[j]
                
                # Calcular a distância entre os dois vértices
                dist = ponto_a.distance(ponto_b)
                
                # Verificar se essa distância é a maior encontrada até agora
                if dist > maior_distancia:
                    maior_distancia = dist
        
        # maior_lado (distância), p1 e p2 (geom Pontos) e lado_mais_longo (geom Linha)
        p1 = p2 = None
        maior_lado = 0

        for i in range(len(vertices) - 1):
            ponto_a = vertices[i]
            ponto_b = vertices[i + 1]
            
            # Calcular a distância entre os dois pontos
            dist = ponto_a.distance(ponto_b)
            
            # Verificar se essa distância é a maior
            if dist > maior_lado:
                maior_lado = dist
                p1 = ponto_a
                p2 = ponto_b

        lado_mais_longo = QgsGeometry.fromPolylineXY([QgsPointXY(p1), QgsPointXY(p2)])
        
        # Criar a linha estendida e depois realizar a interseção
        dx = p2.x() - p1.x()
        dy = p2.y() - p1.y()
        angulo = math.atan2(dy, dx)
        
        extensao_x = maior_distancia * math.cos(angulo)
        extensao_y = maior_distancia * math.sin(angulo)
        
        p1_estendido = QgsPointXY(p1.x() - extensao_x ,p1.y() - extensao_y)
        p2_estendido = QgsPointXY(p2.x() + extensao_x ,p2.y() + extensao_y)
        lado_estendido = QgsGeometry.fromPolylineXY([QgsPointXY(p1_estendido), QgsPointXY(p2_estendido)])
        
        # Agora, encontrar o vértice mais oposto -> dist_P (distância) e ponto_oposto (geom Ponto)
        ponto_oposto = None
        dist_P = 0 

        for i in range(len(vertices)):
            ponto_atual = vertices[i]
            
            # Calcular a distância entre o ponto atual e o maior lado do polígono
            dist = lado_mais_longo.distance(QgsGeometry.fromPointXY(QgsPointXY(ponto_atual)))
             
            # Verificar se é a maior distância
            if dist > dist_P:
                dist_P = dist
                ponto_oposto = ponto_atual
        
        # Criar a linha temporária sobre o lado mais longo do Polígono = Primeira Linha  
        # lado_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Lado Mais Longo', 'memory')
        # lado_provider = lado_layer.dataProvider()
        # lado_provider.addAttributes([QgsField('id', QVariant.Int)])
        # lado_layer.updateFields()

        # lado_feature = QgsFeature()
        # lado_feature.setGeometry(lado_mais_longo)
        # lado_feature.setAttributes([1]) 
        # lado_provider.addFeature(lado_feature)
        
        # QgsProject.instance().addMapLayer(lado_layer)

        # Criar camada temporária para o ponto oposto
        # ponto_layer = QgsVectorLayer('Point?crs=' + crs.authid(), 'Ponto Oposto', 'memory')
        # ponto_provider = ponto_layer.dataProvider()
        # ponto_provider.addAttributes([QgsField('id', QVariant.Int)])
        # ponto_layer.updateFields()

        # ponto_feature = QgsFeature()
        # ponto_feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(ponto_oposto)))
        # ponto_feature.setAttributes([1])  # Atribuindo um valor qualquer, pode ser ajustado
        # ponto_provider.addFeature(ponto_feature)

        # QgsProject.instance().addMapLayer(ponto_layer)
        
        # Criar as Paralelas - temos: lado_mais_longo e ponto_oposto
        paralelas_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linhas Paralelas', 'memory')
        paralelas_provider = paralelas_layer.dataProvider()
        paralelas_provider.addAttributes([QgsField('id', QVariant.Int)])
        paralelas_layer.updateFields()
        
        # Incluir o lado mais longo como a primeira linha paralela
        linha_id = 1
        paralela_feature = QgsFeature()
        paralela_feature.setGeometry(lado_estendido)
        paralela_feature.setAttributes([linha_id])
        paralelas_provider.addFeature(paralela_feature)
        
        # Calcular o produto vetorial para determinar a direção das linhas paralelas
        vetor_linha = QgsPointXY(p2.x() - p1.x(), p2.y() - p1.y())  # Vetor da linha
        vetor_ponto = QgsPointXY(ponto_oposto.x() - p1.x(), ponto_oposto.y() - p1.y())
        direcao = vetor_linha.x() * vetor_ponto.y() - vetor_linha.y() * vetor_ponto.x()
        if direcao > 0:
            sentido = 1  # Ponto está à direita
        else:
            sentido = -1 # Ponto está à esquerda
            
        deslocamento = 0
        linha_base = paralelas_layer
        
        #feedback.pushInfo(f"Sentido: {sentido}, Dist_P: {dist_P}")
        
        while abs(deslocamento) < dist_P: # Linhas paralelas a partir da Linha criada
            linha_id += 1
            
            parameters = {
                'INPUT': linha_base,
                'DISTANCE': deltaLat * sentido,
                'OUTPUT': 'memory:'
            }
        
            result = processing.run("native:offsetline", parameters)
            linha_paralela_layer = result['OUTPUT']
            
            feature = next(linha_paralela_layer.getFeatures(), None)
            linha_geom = feature.geometry()
            intersecao_geom = linha_geom.intersection(geom)
            
            paralela_feature = QgsFeature()
            paralela_feature.setGeometry(intersecao_geom)
            paralela_feature.setAttributes([linha_id])
            paralelas_layer.dataProvider().addFeature(paralela_feature)
            paralelas_layer.updateExtents()
            
            linha_base = linha_paralela_layer
           
            deslocamento += deltaLat * sentido

        # Interseção da linha base (lado estendido) com o polígono
        primeira_linha = next(paralelas_layer.getFeatures())
        primeira_linha.setGeometry(lado_mais_longo)
        paralelas_provider.changeGeometryValues({primeira_linha.id(): lado_mais_longo})
        paralelas_layer.updateExtents()

        # Verificar se há linhas fora do polígono
        linha_features = list(paralelas_layer.getFeatures())
        
        # Lista para armazenar os IDs das feições a serem deletadas
        ids_para_remover = []
        
        for linha in linha_features:
            geom_linha = linha.geometry()
            
            # Verificar se a geometria da linha está fora do polígono
            intersecao_geom = geom_linha.intersection(geom)
            if intersecao_geom.isEmpty():
                # Adicionar o ID da feição à lista para remoção se estiver fora
                ids_para_remover.append(linha.id())
                
        # Remover as feições fora ou sobre o polígono
        if ids_para_remover:
            paralelas_provider.deleteFeatures(ids_para_remover)
            paralelas_layer.updateExtents()
        
        # Adicionar a camada ao projeto       
        #QgsProject.instance().addMapLayer(paralelas_layer)
        
        # Geração das linhas de costura diretamente na camada Linha de Voo
        paralelas_features = list(paralelas_layer.getFeatures())

        # Criar a camada de linha de voo
        linha_voo_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linha de Voo', 'memory')
        linha_voo_provider = linha_voo_layer.dataProvider()
        linha_voo_provider.addAttributes([QgsField('id', QVariant.Int)])
        linha_voo_layer.updateFields()

        # Adicionar as feições ordenadas à camada de linha de voo
        linha_id = 1  # Iniciar a numeração das linhas de voo a partir de 1

        # A primeira linha é a linha inicial
        for feature in paralelas_features:
            feature.setAttributes([linha_id])  # Atribui o ID à linha
            linha_voo_provider.addFeature(feature)  # Adiciona a linha na camada
            linha_id += 1  # Incrementa a numeração

        # Iterar pelas linhas paralelas consecutivas para gerar conexões
        for i in range(len(paralelas_features) - 1):
            linha_atual = paralelas_features[i]
            linha_seguinte = paralelas_features[i + 1]

            geom_atual = linha_atual.geometry()
            geom_seguinte = linha_seguinte.geometry()

            # Obter os extremos das linhas (converter iteradores em listas)
            extremos_atual = list(geom_atual.vertices())
            extremos_seguinte = list(geom_seguinte.vertices())

            # Criar conexões alternadas pelas laterais do polígono
            if i % 2 == 0:  # Conecta lateral direita
                ponto_inicio = QgsPointXY(extremos_atual[-1])  # Extremo direito da linha atual
                ponto_fim = QgsPointXY(extremos_seguinte[-1])  # Extremo direito da próxima linha
            else:  # Conecta lateral esquerda
                ponto_inicio = QgsPointXY(extremos_atual[0])   # Extremo esquerdo da linha atual
                ponto_fim = QgsPointXY(extremos_seguinte[0])   # Extremo esquerdo da próxima linha

            # Criar a linha de conexão
            conexao_geom = QgsGeometry.fromPolylineXY([ponto_inicio, ponto_fim])
            conexao_feature = QgsFeature()
            conexao_feature.setGeometry(conexao_geom)
            conexao_feature.setAttributes([linha_id])  # ID para a linha de conexão
            linha_voo_provider.addFeature(conexao_feature)

            linha_id += 1  # Incrementa a numeração após cada conexão

        # Atualizar extensão da camada de resultado
        linha_voo_layer.updateExtents()

        # Adicionar a camada final ao projeto
        QgsProject.instance().addMapLayer(linha_voo_layer)
        
        
        """
        # =====================================================================
        # =====Criar a camada Pontos de Fotos==================================
        
        # Criar uma camada Ponto com os deltaFront sobre a linha
        pontos_fotos = QgsVectorLayer(f"Point?crs={crs}", "PontosFotos", "memory")
        pontos_provider = pontos_fotos.dataProvider()

        # Definir campos
        campos = QgsFields()
        campos.append(QgsField("id", QVariant.Int))
        campos.append(QgsField("latitude", QVariant.Double))
        campos.append(QgsField("longitude", QVariant.Double))
        pontos_provider.addAttributes(campos)
        pontos_fotos.updateFields()

        # Iterar sobre as linhas e criar pontos espaçados
        features = linha_voo_layer.getFeatures()
        pontoID = 0

        for f in features:
            geom = f.geometry()
            distVoo = geom.length()
            
            x = 0
            while x < distVoo:
                ponto = geom.interpolate(x).asPoint()
                
                nova_feature = QgsFeature()
                nova_feature.setFields(campos)
                nova_feature.setAttribute("id", pontoID)
                nova_feature.setAttribute("latitude", ponto.y())
                nova_feature.setAttribute("longitude", ponto.x())
                
                nova_feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(ponto)))
                
                pontos_provider.addFeature(nova_feature)
                
                pontoID += 1
                x += deltaFront

        # Adicionar camada de pontos ao projeto
        QgsProject.instance().addMapLayer(pontos_fotos)

        # Simbologia e Rótulo
        simbolo = QgsMarkerSymbol.createSimple({'color': 'blue', 'size': '3'})
        renderer = QgsSingleSymbolRenderer(simbolo)
        pontos_fotos.setRenderer(renderer)

        settings = QgsPalLayerSettings()
        settings.fieldName = "id"
        settings.isExpression = True
        settings.enabled = True

        textoF = QgsTextFormat()
        textoF.setFont(QFont("Arial", 10, QFont.Bold))
        textoF.setSize(10)

        bufferS = QgsTextBufferSettings()
        bufferS.setEnabled(True)
        bufferS.setSize(1)  # Tamanho do buffer em milímetros
        bufferS.setColor(QColor("white"))  # Cor do buffer

        textoF.setBuffer(bufferS)
        settings.setFormat(textoF)

        pontos_fotos.setLabelsEnabled(True)
        pontos_fotos.setLabeling(QgsVectorLayerSimpleLabeling(settings))

        pontos_fotos.triggerRepaint()
        QgsProject.instance().addMapLayer(pontos_fotos)
        """
        return {}
        
    def name(self):
        return 'PlanoVooH'.lower()

    def displayName(self):
        return self.tr('Pontos Fotos - Voo Horizontal')

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''
        
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PlanoVoo_H()
    
    def icon(self):
        return QIcon(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'images/PlanoVoo.png'))
    
    texto = "Este algoritmo calcula a sobreposição lateral e frontal de Voo de Drone, \
            fornecendo uma camada da 'Linha do Voo' e uma camada dos 'Pontos' para Fotos. \
            Gera ainda: a planilha CSV para importar no Litchi e o arquivo KML para Google Earth. \
            Se você usa um aplicativo para Voo que não seja o Litchi, pode usar os pontos gerados no QGIS."
    figura = 'images/PlanoVoo1.jpg'

    def shortHelpString(self):
        corpo = '''<div align="center">
                      <img src="'''+ os.path.join(os.path.dirname(os.path.dirname(__file__)), self.figura) +'''">
                      </div>
                      <div align="right">
                      <p align="right">
                      <b>'Autor: Prof Cazaroli     -     Leandro França'</b>
                      </p>'Geoone'</div>
                    </div>'''
        return self.tr(self.texto) + corpo
